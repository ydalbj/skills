### 缓存问题 

参考资料(https://www.iteye.com/blog/carlosfu-2269687)
##### 缓存穿透

缓存穿透是指查询一个不存在的数据,缓存中不存在,就要到存储层去查询.在流量大时,DB可能就要挂掉了.
如果有人利用不存在数据的查询条件,频繁请求,就有可能使我们的系统挂掉,这就是漏洞.

解决方案

  * 最常见的解决方案是采用布隆过滤器,将所有有可能存在的数据哈希到一个足够大的bitmap中,一定不存在的key,会被这个bitmap过滤掉,
从而避免对底层存储系统的查询压力.
  * 另外一个,如果查询返回数据为空(不管数据不存在还是,系统故障),仍然对控结果缓存,但过期时间很短,不超过5分钟

##### 缓存雪崩

缓存雪崩是指我们设置缓存时,采用了相同的过期时间,导致缓存同时失效,请求全部转发到DB,DB瞬时压力过重.

解决方案

* 加锁或队列方式保证缓存的单线程写
* 可以在原有失效时间基础上增加一个随机值(1-5分钟)

##### 缓存击穿
对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。

缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

解决方案
* 业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。

SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果

* 在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。

* 永远不过期

(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。

(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期

* 资源保护
采用netflix的hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可。
