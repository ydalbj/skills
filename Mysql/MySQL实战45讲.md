### 01 | 基础架构：一条SQL查询语句是如何执行的？

> server层和存储引擎层

> server层有连接器、查询缓存、分析器、优化器、执行器,以及所有的内置函数,所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等

> 存储引擎层负责数据的存储和提取

> 建议你不要使用查询缓存。因为查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空

### 02 | 日志系统：一条SQL更新语句是如何执行的？

> WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘.

> write pos, checkpoint

> 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe

> redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog

> redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”

> 将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。这是为了让两份日志之间的逻辑一致

### 03 | 事务隔离：为什么你改了我还看不见？

> SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）

> 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

##### 事务隔离的实现
> 在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。

> 尽量不要使用长事务

> 建议你总是使用 set autocommit=1, 通过显式语句的方式来启动事务。

> 对于一个需要频繁使用事务的业务，减少了语句的交互次数,我建议你使用 commit work and chain 语法。

查询长事务
```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

### 04 | 深入浅出索引（上）

索引的常见模型:哈希表,有序数组，二叉树(MySQL B+树)

> 哈希表这种结构适用于只有等值查询的场景,不适合范围查询

> 有序数组在等值查询和范围查询场景中的性能就都非常优秀，但插入效率低。只适用于静态存储引擎。

InnoDB 的索引模型，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。

> 每一个索引在 InnoDB 里面对应一棵 B+ 树。

> B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。由于 InnoDB 是索引组织表，一般情况下我

> 索引类型分为主键索引和非主键索引

> 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）

> 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）

> 基于非主键索引的查询需要回表多扫描一棵索引树

> 如果要插入的数据页满了，就要多申请一个数据页，称为页分裂。

> 自增主键的插入数据模式，可以避免主键索引页分裂

> 主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

### 06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？

根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。

##### 全局锁
MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)

> 全局锁的典型使用场景是，做全库逻辑备份。(支持事务的也可以在可重复读隔离级别下开启一个事务。mysqldump 使用参数　－single-transaction)

##### 表级锁
MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

* 表锁
> 表锁的语法是 lock tables … read/write,可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。

> 在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。

* 元数据锁
> 另一类表级的锁是 MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被自动加上。

* 安全的给热点表加字段

> 可在alter表的时候，增加等待时间，如果在等待的时间内拿到了MDL锁，就可以变更，如果拿不到也不要堵塞业务查询。 之后再重复尝试修改

> Mysql未支持alter等待时间， AliSQL和MariaDb支持
```sql
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ... 
```

* OnlineDDL步骤

1. 拿MDL写锁
2. 降级成MDL读锁
3. 真正做DDL
4. 升级成MDL写锁
5. 释放MDL锁


### 09 | 普通索引和唯一索引,应该怎么选择

  * 查询过程

    - InnoDB的数据是按数据页为单位来读写的.当需要读一条记录的时候,是以页为单位,整体读入内存.每个数据页的大小默认是16kb.


  * 更新过程

    - 当需要更新一个数据页时,如果数据页在内存中就直接更新,否则,InnoDB会将更新操作缓存在change buffer中,这样就不需要从磁盘中读入这个数据页了.

    - 将change buffer中的操作应用的原数据页,得到更新结果的过程称为merge.访问这个数据页会触发merge,此外系统后台线程会定期merge.数据库正常关闭(shutdown),也会执行merge操作.

    - 将更新操作先记录在change buffer,减少读磁盘,语句的执行速度会得到提升.还能避免占用内存,提高内存利用率.

    - 唯一索引的更新不能使用change buffer,因为先要读入内存,检查唯一性.

### 10 | 怎么给字符串加索引

  1. 直接创建完整索引，这样可能比较占用空间

  2. 创建前缀索引，节省空间，但会增加查询扫描行数，并且不能使用覆盖索引

  3. 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题（如身份证号）

  4. 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。

### 18 | 为什么这些SQL语句逻辑相同，性能却差异巨大？

* 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能

* 隐式类型转换，隐式字符编码转换会在索引字段做函数操作，同样会导致不走树搜索，而是全索引扫描

