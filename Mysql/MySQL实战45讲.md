### 01 | 基础架构：一条SQL查询语句是如何执行的？

> server层和存储引擎层

> server层有连接器、查询缓存、分析器、优化器、执行器,以及所有的内置函数,所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等

> 存储引擎层负责数据的存储和提取

> 建议你不要使用查询缓存。因为查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空

### 02 | 日志系统：一条SQL更新语句是如何执行的？

> WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘.

> write pos, checkpoint

> 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe

> redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog

> redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”

> 将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。这是为了让两份日志之间的逻辑一致

### 09 | 普通索引和唯一索引,应该怎么选择

  * 查询过程

    - InnoDB的数据是按数据页为单位来读写的.当需要读一条记录的时候,是以页为单位,整体读入内存.每个数据页的大小默认是16kb.


  * 更新过程

    - 当需要更新一个数据页时,如果数据页在内存中就直接更新,否则,InnoDB会将更新操作缓存在change buffer中,这样就不需要从磁盘中读入这个数据页了.

    - 将change buffer中的操作应用的原数据页,得到更新结果的过程称为merge.访问这个数据页会触发merge,此外系统后台线程会定期merge.数据库正常关闭(shutdown),也会执行merge操作.

    - 将更新操作先记录在change buffer,减少读磁盘,语句的执行速度会得到提升.还能避免占用内存,提高内存利用率.

    - 唯一索引的更新不能使用change buffer,因为先要读入内存,检查唯一性.

### 10 | 怎么给字符串加索引

  1. 直接创建完整索引，这样可能比较占用空间

  2. 创建前缀索引，节省空间，但会增加查询扫描行数，并且不能使用覆盖索引

  3. 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题（如身份证号）

  4. 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。

### 18 | 为什么这些SQL语句逻辑相同，性能却差异巨大？

* 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能

* 隐式类型转换，隐式字符编码转换会在索引字段做函数操作，同样会导致不走树搜索，而是全索引扫描

